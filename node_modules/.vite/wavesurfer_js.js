import {
  init_define_process_env
} from "./chunk-TMPXONF3.js";

// dep:wavesurfer_js
init_define_process_env();

// node_modules/wavesurfer.js/dist/wavesurfer.esm.js
init_define_process_env();
function t(t2, e2, i2, n2) {
  return new (i2 || (i2 = Promise))(function(s2, r2) {
    function o2(t3) {
      try {
        h2(n2.next(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function a2(t3) {
      try {
        h2(n2.throw(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function h2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(o2, a2);
    }
    h2((n2 = n2.apply(t2, e2 || [])).next());
  });
}
typeof SuppressedError == "function" && SuppressedError;
var e = class {
  constructor() {
    this.listeners = {};
  }
  on(t2, e2, i2) {
    if (this.listeners[t2] || (this.listeners[t2] = new Set()), this.listeners[t2].add(e2), i2 == null ? void 0 : i2.once) {
      const i3 = () => {
        this.un(t2, i3), this.un(t2, e2);
      };
      return this.on(t2, i3), i3;
    }
    return () => this.un(t2, e2);
  }
  un(t2, e2) {
    var i2;
    (i2 = this.listeners[t2]) === null || i2 === void 0 || i2.delete(e2);
  }
  once(t2, e2) {
    return this.on(t2, e2, { once: true });
  }
  unAll() {
    this.listeners = {};
  }
  emit(t2, ...e2) {
    this.listeners[t2] && this.listeners[t2].forEach((t3) => t3(...e2));
  }
};
var i = { decode: function(e2, i2) {
  return t(this, void 0, void 0, function* () {
    const t2 = new AudioContext({ sampleRate: i2 });
    return t2.decodeAudioData(e2).finally(() => t2.close());
  });
}, createBuffer: function(t2, e2) {
  return typeof t2[0] == "number" && (t2 = [t2]), function(t3) {
    const e3 = t3[0];
    if (e3.some((t4) => t4 > 1 || t4 < -1)) {
      const i2 = e3.length;
      let n2 = 0;
      for (let t4 = 0; t4 < i2; t4++) {
        const i3 = Math.abs(e3[t4]);
        i3 > n2 && (n2 = i3);
      }
      for (const e4 of t3)
        for (let t4 = 0; t4 < i2; t4++)
          e4[t4] /= n2;
    }
  }(t2), { duration: e2, length: t2[0].length, sampleRate: t2[0].length / e2, numberOfChannels: t2.length, getChannelData: (e3) => t2 == null ? void 0 : t2[e3], copyFromChannel: AudioBuffer.prototype.copyFromChannel, copyToChannel: AudioBuffer.prototype.copyToChannel };
} };
function n(t2, e2) {
  const i2 = e2.xmlns ? document.createElementNS(e2.xmlns, t2) : document.createElement(t2);
  for (const [t3, s2] of Object.entries(e2))
    if (t3 === "children")
      for (const [t4, s3] of Object.entries(e2))
        typeof s3 == "string" ? i2.appendChild(document.createTextNode(s3)) : i2.appendChild(n(t4, s3));
    else
      t3 === "style" ? Object.assign(i2.style, s2) : t3 === "textContent" ? i2.textContent = s2 : i2.setAttribute(t3, s2.toString());
  return i2;
}
function s(t2, e2, i2) {
  const s2 = n(t2, e2 || {});
  return i2 == null || i2.appendChild(s2), s2;
}
var r = Object.freeze({ __proto__: null, createElement: s, default: s });
var o = { fetchBlob: function(e2, i2, n2) {
  return t(this, void 0, void 0, function* () {
    const s2 = yield fetch(e2, n2);
    if (s2.status >= 400)
      throw new Error(`Failed to fetch ${e2}: ${s2.status} (${s2.statusText})`);
    return function(e3, i3) {
      t(this, void 0, void 0, function* () {
        if (!e3.body || !e3.headers)
          return;
        const n3 = e3.body.getReader(), s3 = Number(e3.headers.get("Content-Length")) || 0;
        let r2 = 0;
        const o2 = (e4) => t(this, void 0, void 0, function* () {
          r2 += (e4 == null ? void 0 : e4.length) || 0;
          const t2 = Math.round(r2 / s3 * 100);
          i3(t2);
        }), a2 = () => t(this, void 0, void 0, function* () {
          let t2;
          try {
            t2 = yield n3.read();
          } catch (t3) {
            return;
          }
          t2.done || (o2(t2.value), yield a2());
        });
        a2();
      });
    }(s2.clone(), i2), s2.blob();
  });
} };
var a = class extends e {
  constructor(t2) {
    super(), this.isExternalMedia = false, t2.media ? (this.media = t2.media, this.isExternalMedia = true) : this.media = document.createElement("audio"), t2.mediaControls && (this.media.controls = true), t2.autoplay && (this.media.autoplay = true), t2.playbackRate != null && this.onMediaEvent("canplay", () => {
      t2.playbackRate != null && (this.media.playbackRate = t2.playbackRate);
    }, { once: true });
  }
  onMediaEvent(t2, e2, i2) {
    return this.media.addEventListener(t2, e2, i2), () => this.media.removeEventListener(t2, e2, i2);
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const t2 = this.getSrc();
    t2.startsWith("blob:") && URL.revokeObjectURL(t2);
  }
  canPlayType(t2) {
    return this.media.canPlayType(t2) !== "";
  }
  setSrc(t2, e2) {
    if (this.getSrc() === t2)
      return;
    this.revokeSrc();
    const i2 = e2 instanceof Blob && this.canPlayType(e2.type) ? URL.createObjectURL(e2) : t2;
    this.media.src = i2;
  }
  destroy() {
    this.media.pause(), this.isExternalMedia || (this.media.remove(), this.revokeSrc(), this.media.src = "", this.media.load());
  }
  setMediaElement(t2) {
    this.media = t2;
  }
  play() {
    return t(this, void 0, void 0, function* () {
      return this.media.play();
    });
  }
  pause() {
    this.media.pause();
  }
  isPlaying() {
    return !this.media.paused && !this.media.ended;
  }
  setTime(t2) {
    this.media.currentTime = t2;
  }
  getDuration() {
    return this.media.duration;
  }
  getCurrentTime() {
    return this.media.currentTime;
  }
  getVolume() {
    return this.media.volume;
  }
  setVolume(t2) {
    this.media.volume = t2;
  }
  getMuted() {
    return this.media.muted;
  }
  setMuted(t2) {
    this.media.muted = t2;
  }
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  isSeeking() {
    return this.media.seeking;
  }
  setPlaybackRate(t2, e2) {
    e2 != null && (this.media.preservesPitch = e2), this.media.playbackRate = t2;
  }
  getMediaElement() {
    return this.media;
  }
  setSinkId(t2) {
    return this.media.setSinkId(t2);
  }
};
var h = class extends e {
  constructor(t2, e2) {
    super(), this.timeouts = [], this.isScrollable = false, this.audioData = null, this.resizeObserver = null, this.lastContainerWidth = 0, this.isDragging = false, this.subscriptions = [], this.subscriptions = [], this.options = t2;
    const i2 = this.parentFromOptionsContainer(t2.container);
    this.parent = i2;
    const [n2, s2] = this.initHtml();
    i2.appendChild(n2), this.container = n2, this.scrollContainer = s2.querySelector(".scroll"), this.wrapper = s2.querySelector(".wrapper"), this.canvasWrapper = s2.querySelector(".canvases"), this.progressWrapper = s2.querySelector(".progress"), this.cursor = s2.querySelector(".cursor"), e2 && s2.appendChild(e2), this.initEvents();
  }
  parentFromOptionsContainer(t2) {
    let e2;
    if (typeof t2 == "string" ? e2 = document.querySelector(t2) : t2 instanceof HTMLElement && (e2 = t2), !e2)
      throw new Error("Container not found");
    return e2;
  }
  initEvents() {
    const t2 = (t3) => {
      const e3 = this.wrapper.getBoundingClientRect(), i2 = t3.clientX - e3.left, n2 = t3.clientY - e3.top;
      return [i2 / e3.width, n2 / e3.height];
    };
    this.wrapper.addEventListener("click", (e3) => {
      const [i2, n2] = t2(e3);
      this.emit("click", i2, n2);
    }), this.wrapper.addEventListener("dblclick", (e3) => {
      const [i2, n2] = t2(e3);
      this.emit("dblclick", i2, n2);
    }), this.options.dragToSeek !== true && typeof this.options.dragToSeek != "object" || this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
      const { scrollLeft: t3, scrollWidth: e3, clientWidth: i2 } = this.scrollContainer, n2 = t3 / e3, s2 = (t3 + i2) / e3;
      this.emit("scroll", n2, s2);
    });
    const e2 = this.createDelay(100);
    this.resizeObserver = new ResizeObserver(() => {
      e2().then(() => this.onContainerResize()).catch(() => {
      });
    }), this.resizeObserver.observe(this.scrollContainer);
  }
  onContainerResize() {
    const t2 = this.parent.clientWidth;
    t2 === this.lastContainerWidth && this.options.height !== "auto" || (this.lastContainerWidth = t2, this.reRender());
  }
  initDrag() {
    this.subscriptions.push(function(t2, e2, i2, n2, s2 = 3, r2 = 0, o2 = 100) {
      if (!t2)
        return () => {
        };
      const a2 = matchMedia("(pointer: coarse)").matches;
      let h2 = () => {
      };
      const l2 = (l3) => {
        if (l3.button !== r2)
          return;
        l3.preventDefault(), l3.stopPropagation();
        let d2 = l3.clientX, c2 = l3.clientY, u2 = false;
        const p = Date.now(), m = (n3) => {
          if (n3.preventDefault(), n3.stopPropagation(), a2 && Date.now() - p < o2)
            return;
          const r3 = n3.clientX, h3 = n3.clientY, l4 = r3 - d2, m2 = h3 - c2;
          if (u2 || Math.abs(l4) > s2 || Math.abs(m2) > s2) {
            const n4 = t2.getBoundingClientRect(), { left: s3, top: o3 } = n4;
            u2 || (i2 == null || i2(d2 - s3, c2 - o3), u2 = true), e2(l4, m2, r3 - s3, h3 - o3), d2 = r3, c2 = h3;
          }
        }, f = (e3) => {
          if (u2) {
            const i3 = e3.clientX, s3 = e3.clientY, r3 = t2.getBoundingClientRect(), { left: o3, top: a3 } = r3;
            n2 == null || n2(i3 - o3, s3 - a3);
          }
          h2();
        }, g = (t3) => {
          t3.relatedTarget && t3.relatedTarget !== document.documentElement || f(t3);
        }, v = (t3) => {
          u2 && (t3.stopPropagation(), t3.preventDefault());
        }, b = (t3) => {
          u2 && t3.preventDefault();
        };
        document.addEventListener("pointermove", m), document.addEventListener("pointerup", f), document.addEventListener("pointerout", g), document.addEventListener("pointercancel", g), document.addEventListener("touchmove", b, { passive: false }), document.addEventListener("click", v, { capture: true }), h2 = () => {
          document.removeEventListener("pointermove", m), document.removeEventListener("pointerup", f), document.removeEventListener("pointerout", g), document.removeEventListener("pointercancel", g), document.removeEventListener("touchmove", b), setTimeout(() => {
            document.removeEventListener("click", v, { capture: true });
          }, 10);
        };
      };
      return t2.addEventListener("pointerdown", l2), () => {
        h2(), t2.removeEventListener("pointerdown", l2);
      };
    }(this.wrapper, (t2, e2, i2) => {
      this.emit("drag", Math.max(0, Math.min(1, i2 / this.wrapper.getBoundingClientRect().width)));
    }, (t2) => {
      this.isDragging = true, this.emit("dragstart", Math.max(0, Math.min(1, t2 / this.wrapper.getBoundingClientRect().width)));
    }, (t2) => {
      this.isDragging = false, this.emit("dragend", Math.max(0, Math.min(1, t2 / this.wrapper.getBoundingClientRect().width)));
    }));
  }
  getHeight(t2, e2) {
    var i2;
    const n2 = ((i2 = this.audioData) === null || i2 === void 0 ? void 0 : i2.numberOfChannels) || 1;
    if (t2 == null)
      return 128;
    if (!isNaN(Number(t2)))
      return Number(t2);
    if (t2 === "auto") {
      const t3 = this.parent.clientHeight || 128;
      return (e2 == null ? void 0 : e2.every((t4) => !t4.overlay)) ? t3 / n2 : t3;
    }
    return 128;
  }
  initHtml() {
    const t2 = document.createElement("div"), e2 = t2.attachShadow({ mode: "open" });
    return e2.innerHTML = `
      <style>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height, this.options.splitChannels)}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [t2, e2];
  }
  setOptions(t2) {
    if (this.options.container !== t2.container) {
      const e2 = this.parentFromOptionsContainer(t2.container);
      e2.appendChild(this.container), this.parent = e2;
    }
    t2.dragToSeek !== true && typeof this.options.dragToSeek != "object" || this.initDrag(), this.options = t2, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  setScroll(t2) {
    this.scrollContainer.scrollLeft = t2;
  }
  setScrollPercentage(t2) {
    const { scrollWidth: e2 } = this.scrollContainer, i2 = e2 * t2;
    this.setScroll(i2);
  }
  destroy() {
    var t2;
    this.subscriptions.forEach((t3) => t3()), this.container.remove(), (t2 = this.resizeObserver) === null || t2 === void 0 || t2.disconnect();
  }
  createDelay(t2 = 10) {
    let e2, i2;
    const n2 = () => {
      e2 && clearTimeout(e2), i2 && i2();
    };
    return this.timeouts.push(n2), () => new Promise((s2, r2) => {
      n2(), i2 = r2, e2 = setTimeout(() => {
        e2 = void 0, i2 = void 0, s2();
      }, t2);
    });
  }
  convertColorValues(t2) {
    if (!Array.isArray(t2))
      return t2 || "";
    if (t2.length < 2)
      return t2[0] || "";
    const e2 = document.createElement("canvas"), i2 = e2.getContext("2d"), n2 = e2.height * (window.devicePixelRatio || 1), s2 = i2.createLinearGradient(0, 0, 0, n2), r2 = 1 / (t2.length - 1);
    return t2.forEach((t3, e3) => {
      const i3 = e3 * r2;
      s2.addColorStop(i3, t3);
    }), s2;
  }
  renderBarWaveform(t2, e2, i2, n2) {
    const s2 = t2[0], r2 = t2[1] || t2[0], o2 = s2.length, { width: a2, height: h2 } = i2.canvas, l2 = h2 / 2, d2 = window.devicePixelRatio || 1, c2 = e2.barWidth ? e2.barWidth * d2 : 1, u2 = e2.barGap ? e2.barGap * d2 : e2.barWidth ? c2 / 2 : 0, p = e2.barRadius || 0, m = a2 / (c2 + u2) / o2, f = p && "roundRect" in i2 ? "roundRect" : "rect";
    i2.beginPath();
    let g = 0, v = 0, b = 0;
    for (let t3 = 0; t3 <= o2; t3++) {
      const o3 = Math.round(t3 * m);
      if (o3 > g) {
        const t4 = Math.round(v * l2 * n2), s3 = t4 + Math.round(b * l2 * n2) || 1;
        let r3 = l2 - t4;
        e2.barAlign === "top" ? r3 = 0 : e2.barAlign === "bottom" && (r3 = h2 - s3), i2[f](g * (c2 + u2), r3, c2, s3, p), g = o3, v = 0, b = 0;
      }
      const a3 = Math.abs(s2[t3] || 0), d3 = Math.abs(r2[t3] || 0);
      a3 > v && (v = a3), d3 > b && (b = d3);
    }
    i2.fill(), i2.closePath();
  }
  renderLineWaveform(t2, e2, i2, n2) {
    const s2 = (e3) => {
      const s3 = t2[e3] || t2[0], r2 = s3.length, { height: o2 } = i2.canvas, a2 = o2 / 2, h2 = i2.canvas.width / r2;
      i2.moveTo(0, a2);
      let l2 = 0, d2 = 0;
      for (let t3 = 0; t3 <= r2; t3++) {
        const r3 = Math.round(t3 * h2);
        if (r3 > l2) {
          const t4 = a2 + (Math.round(d2 * a2 * n2) || 1) * (e3 === 0 ? -1 : 1);
          i2.lineTo(l2, t4), l2 = r3, d2 = 0;
        }
        const o3 = Math.abs(s3[t3] || 0);
        o3 > d2 && (d2 = o3);
      }
      i2.lineTo(l2, a2);
    };
    i2.beginPath(), s2(0), s2(1), i2.fill(), i2.closePath();
  }
  renderWaveform(t2, e2, i2) {
    if (i2.fillStyle = this.convertColorValues(e2.waveColor), e2.renderFunction)
      return void e2.renderFunction(t2, i2);
    let n2 = e2.barHeight || 1;
    if (e2.normalize) {
      const e3 = Array.from(t2[0]).reduce((t3, e4) => Math.max(t3, Math.abs(e4)), 0);
      n2 = e3 ? 1 / e3 : 1;
    }
    e2.barWidth || e2.barGap || e2.barAlign ? this.renderBarWaveform(t2, e2, i2, n2) : this.renderLineWaveform(t2, e2, i2, n2);
  }
  renderSingleCanvas(t2, e2, i2, n2, s2, r2, o2) {
    const a2 = window.devicePixelRatio || 1, h2 = document.createElement("canvas");
    h2.width = Math.round(i2 * a2), h2.height = Math.round(n2 * a2), h2.style.width = `${i2}px`, h2.style.height = `${n2}px`, h2.style.left = `${Math.round(s2)}px`, r2.appendChild(h2);
    const l2 = h2.getContext("2d");
    if (this.renderWaveform(t2, e2, l2), h2.width > 0 && h2.height > 0) {
      const t3 = h2.cloneNode(), i3 = t3.getContext("2d");
      i3.drawImage(h2, 0, 0), i3.globalCompositeOperation = "source-in", i3.fillStyle = this.convertColorValues(e2.progressColor), i3.fillRect(0, 0, h2.width, h2.height), o2.appendChild(t3);
    }
  }
  renderMultiCanvas(e2, i2, n2, s2, r2, o2) {
    return t(this, void 0, void 0, function* () {
      const a2 = window.devicePixelRatio || 1, l2 = n2 / a2;
      let d2 = Math.min(h.MAX_CANVAS_WIDTH, this.scrollContainer.clientWidth);
      if (i2.barWidth || i2.barGap) {
        const t2 = i2.barWidth || 0.5, e3 = t2 + (i2.barGap || t2 / 2);
        d2 % e3 != 0 && (d2 = Math.floor(d2 / e3) * e3);
      }
      const c2 = (t2) => {
        const n3 = t2 * d2, a3 = Math.min(l2 - n3, d2), h2 = e2.map((t3) => {
          const e3 = Math.floor(n3 / l2 * t3.length), i3 = Math.floor((n3 + a3) / l2 * t3.length);
          return t3.slice(e3, i3);
        });
        this.renderSingleCanvas(h2, i2, a3, s2, n3, r2, o2);
      }, u2 = Math.ceil(l2 / d2);
      if (u2 === 1)
        return void c2(0);
      const p = this.scrollContainer.scrollLeft / l2, m = Math.floor(p * u2);
      c2(m), c2(m + 1), yield Promise.all([(() => t(this, void 0, void 0, function* () {
        const t2 = this.createDelay();
        for (let e3 = m - 1; e3 >= 0; e3--)
          yield t2(), c2(e3);
      }))(), (() => t(this, void 0, void 0, function* () {
        const t2 = this.createDelay();
        for (let e3 = m + 2; e3 < u2; e3++)
          yield t2(), c2(e3);
      }))()]);
    });
  }
  renderChannel(e2, i2, n2, s2) {
    return t(this, void 0, void 0, function* () {
      var { overlay: t2 } = i2, r2 = function(t3, e3) {
        var i3 = {};
        for (var n3 in t3)
          Object.prototype.hasOwnProperty.call(t3, n3) && e3.indexOf(n3) < 0 && (i3[n3] = t3[n3]);
        if (t3 != null && typeof Object.getOwnPropertySymbols == "function") {
          var s3 = 0;
          for (n3 = Object.getOwnPropertySymbols(t3); s3 < n3.length; s3++)
            e3.indexOf(n3[s3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, n3[s3]) && (i3[n3[s3]] = t3[n3[s3]]);
        }
        return i3;
      }(i2, ["overlay"]);
      const o2 = document.createElement("div"), a2 = this.getHeight(r2.height, r2.splitChannels);
      o2.style.height = `${a2}px`, t2 && s2 > 0 && (o2.style.marginTop = `-${a2}px`), this.canvasWrapper.style.minHeight = `${a2}px`, this.canvasWrapper.appendChild(o2);
      const h2 = o2.cloneNode();
      this.progressWrapper.appendChild(h2), yield this.renderMultiCanvas(e2, r2, n2, a2, o2, h2);
    });
  }
  render(e2) {
    return t(this, void 0, void 0, function* () {
      this.timeouts.forEach((t3) => t3()), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", this.options.width != null && (this.scrollContainer.style.width = typeof this.options.width == "number" ? `${this.options.width}px` : this.options.width);
      const t2 = window.devicePixelRatio || 1, i2 = this.scrollContainer.clientWidth, n2 = Math.ceil(e2.duration * (this.options.minPxPerSec || 0));
      this.isScrollable = n2 > i2;
      const s2 = this.options.fillParent && !this.isScrollable, r2 = (s2 ? i2 : n2) * t2;
      this.wrapper.style.width = s2 ? "100%" : `${n2}px`, this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.audioData = e2, this.emit("render");
      try {
        if (this.options.splitChannels)
          yield Promise.all(Array.from({ length: e2.numberOfChannels }).map((t3, i3) => {
            var n3;
            const s3 = Object.assign(Object.assign({}, this.options), (n3 = this.options.splitChannels) === null || n3 === void 0 ? void 0 : n3[i3]);
            return this.renderChannel([e2.getChannelData(i3)], s3, r2, i3);
          }));
        else {
          const t3 = [e2.getChannelData(0)];
          e2.numberOfChannels > 1 && t3.push(e2.getChannelData(1)), yield this.renderChannel(t3, this.options, r2, 0);
        }
      } catch (t3) {
        return;
      }
      this.emit("rendered");
    });
  }
  reRender() {
    if (!this.audioData)
      return;
    const { scrollWidth: t2 } = this.scrollContainer, { right: e2 } = this.progressWrapper.getBoundingClientRect();
    if (this.render(this.audioData), this.isScrollable && t2 !== this.scrollContainer.scrollWidth) {
      const { right: t3 } = this.progressWrapper.getBoundingClientRect();
      let i2 = t3 - e2;
      i2 *= 2, i2 = i2 < 0 ? Math.floor(i2) : Math.ceil(i2), i2 /= 2, this.scrollContainer.scrollLeft += i2;
    }
  }
  zoom(t2) {
    this.options.minPxPerSec = t2, this.reRender();
  }
  scrollIntoView(t2, e2 = false) {
    const { scrollLeft: i2, scrollWidth: n2, clientWidth: s2 } = this.scrollContainer, r2 = t2 * n2, o2 = i2, a2 = i2 + s2, h2 = s2 / 2;
    if (this.isDragging) {
      const t3 = 30;
      r2 + t3 > a2 ? this.scrollContainer.scrollLeft += t3 : r2 - t3 < o2 && (this.scrollContainer.scrollLeft -= t3);
    } else {
      (r2 < o2 || r2 > a2) && (this.scrollContainer.scrollLeft = r2 - (this.options.autoCenter ? h2 : 0));
      const t3 = r2 - i2 - h2;
      e2 && this.options.autoCenter && t3 > 0 && (this.scrollContainer.scrollLeft += Math.min(t3, 10));
    }
    {
      const t3 = this.scrollContainer.scrollLeft, e3 = t3 / n2, i3 = (t3 + s2) / n2;
      this.emit("scroll", e3, i3);
    }
  }
  renderProgress(t2, e2) {
    if (isNaN(t2))
      return;
    const i2 = 100 * t2;
    this.canvasWrapper.style.clipPath = `polygon(${i2}% 0, 100% 0, 100% 100%, ${i2}% 100%)`, this.progressWrapper.style.width = `${i2}%`, this.cursor.style.left = `${i2}%`, this.cursor.style.transform = `translateX(-${Math.round(i2) === 100 ? this.options.cursorWidth : 0}px)`, this.isScrollable && this.options.autoScroll && this.scrollIntoView(t2, e2);
  }
  exportImage(e2, i2, n2) {
    return t(this, void 0, void 0, function* () {
      const t2 = this.canvasWrapper.querySelectorAll("canvas");
      if (!t2.length)
        throw new Error("No waveform data");
      if (n2 === "dataURL") {
        const n3 = Array.from(t2).map((t3) => t3.toDataURL(e2, i2));
        return Promise.resolve(n3);
      }
      return Promise.all(Array.from(t2).map((t3) => new Promise((n3, s2) => {
        t3.toBlob((t4) => {
          t4 ? n3(t4) : s2(new Error("Could not export image"));
        }, e2, i2);
      })));
    });
  }
};
h.MAX_CANVAS_WIDTH = 4e3;
var l = class extends e {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
};
var d = class extends e {
  constructor(t2 = new AudioContext()) {
    super(), this.bufferNode = null, this.playStartTime = 0, this.playedDuration = 0, this._muted = false, this._playbackRate = 1, this._duration = void 0, this.buffer = null, this.currentSrc = "", this.paused = true, this.crossOrigin = null, this.seeking = false, this.autoplay = false, this.addEventListener = this.on, this.removeEventListener = this.un, this.audioContext = t2, this.gainNode = this.audioContext.createGain(), this.gainNode.connect(this.audioContext.destination);
  }
  load() {
    return t(this, void 0, void 0, function* () {
    });
  }
  get src() {
    return this.currentSrc;
  }
  set src(t2) {
    if (this.currentSrc = t2, this._duration = void 0, !t2)
      return this.buffer = null, void this.emit("emptied");
    fetch(t2).then((e2) => {
      if (e2.status >= 400)
        throw new Error(`Failed to fetch ${t2}: ${e2.status} (${e2.statusText})`);
      return e2.arrayBuffer();
    }).then((e2) => this.currentSrc !== t2 ? null : this.audioContext.decodeAudioData(e2)).then((e2) => {
      this.currentSrc === t2 && (this.buffer = e2, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
    });
  }
  _play() {
    var t2;
    if (!this.paused)
      return;
    this.paused = false, (t2 = this.bufferNode) === null || t2 === void 0 || t2.disconnect(), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode);
    let e2 = this.playedDuration * this._playbackRate;
    e2 >= this.duration && (e2 = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, e2), this.playStartTime = this.audioContext.currentTime, this.bufferNode.onended = () => {
      this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
    };
  }
  _pause() {
    var t2;
    this.paused = true, (t2 = this.bufferNode) === null || t2 === void 0 || t2.stop(), this.playedDuration += this.audioContext.currentTime - this.playStartTime;
  }
  play() {
    return t(this, void 0, void 0, function* () {
      this.paused && (this._play(), this.emit("play"));
    });
  }
  pause() {
    this.paused || (this._pause(), this.emit("pause"));
  }
  stopAt(t2) {
    var e2, i2;
    const n2 = t2 - this.currentTime;
    (e2 = this.bufferNode) === null || e2 === void 0 || e2.stop(this.audioContext.currentTime + n2), (i2 = this.bufferNode) === null || i2 === void 0 || i2.addEventListener("ended", () => {
      this.bufferNode = null, this.pause();
    }, { once: true });
  }
  setSinkId(e2) {
    return t(this, void 0, void 0, function* () {
      return this.audioContext.setSinkId(e2);
    });
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t2) {
    this._playbackRate = t2, this.bufferNode && (this.bufferNode.playbackRate.value = t2);
  }
  get currentTime() {
    return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
  }
  set currentTime(t2) {
    const e2 = !this.paused;
    e2 && this._pause(), this.playedDuration = t2 / this._playbackRate, e2 && this._play(), this.emit("seeking"), this.emit("timeupdate");
  }
  get duration() {
    var t2, e2;
    return (t2 = this._duration) !== null && t2 !== void 0 ? t2 : ((e2 = this.buffer) === null || e2 === void 0 ? void 0 : e2.duration) || 0;
  }
  set duration(t2) {
    this._duration = t2;
  }
  get volume() {
    return this.gainNode.gain.value;
  }
  set volume(t2) {
    this.gainNode.gain.value = t2, this.emit("volumechange");
  }
  get muted() {
    return this._muted;
  }
  set muted(t2) {
    this._muted !== t2 && (this._muted = t2, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
  }
  canPlayType(t2) {
    return /^(audio|video)\//.test(t2);
  }
  getGainNode() {
    return this.gainNode;
  }
  getChannelData() {
    const t2 = [];
    if (!this.buffer)
      return t2;
    const e2 = this.buffer.numberOfChannels;
    for (let i2 = 0; i2 < e2; i2++)
      t2.push(this.buffer.getChannelData(i2));
    return t2;
  }
};
var c = { waveColor: "#999", progressColor: "#555", cursorWidth: 1, minPxPerSec: 0, fillParent: true, interact: true, dragToSeek: false, autoScroll: true, autoCenter: true, sampleRate: 8e3 };
var u = class extends a {
  static create(t2) {
    return new u(t2);
  }
  constructor(t2) {
    const e2 = t2.media || (t2.backend === "WebAudio" ? new d() : void 0);
    super({ media: e2, mediaControls: t2.mediaControls, autoplay: t2.autoplay, playbackRate: t2.audioRate }), this.plugins = [], this.decodedData = null, this.subscriptions = [], this.mediaSubscriptions = [], this.abortController = null, this.options = Object.assign({}, c, t2), this.timer = new l();
    const i2 = e2 ? void 0 : this.getMediaElement();
    this.renderer = new h(this.options, i2), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
    const n2 = this.options.url || this.getSrc() || "";
    Promise.resolve().then(() => {
      this.emit("init");
      const { peaks: t3, duration: e3 } = this.options;
      (n2 || t3 && e3) && this.load(n2, t3, e3).catch(() => null);
    });
  }
  updateProgress(t2 = this.getCurrentTime()) {
    return this.renderer.renderProgress(t2 / this.getDuration(), this.isPlaying()), t2;
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      if (!this.isSeeking()) {
        const t2 = this.updateProgress();
        this.emit("timeupdate", t2), this.emit("audioprocess", t2);
      }
    }));
  }
  initPlayerEvents() {
    this.isPlaying() && (this.emit("play"), this.timer.start()), this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", () => {
      const t2 = this.updateProgress();
      this.emit("timeupdate", t2);
    }), this.onMediaEvent("play", () => {
      this.emit("play"), this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause"), this.timer.stop();
    }), this.onMediaEvent("emptied", () => {
      this.timer.stop();
    }), this.onMediaEvent("ended", () => {
      this.emit("finish");
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }), this.onMediaEvent("error", (t2) => {
      this.emit("error", t2.error);
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(this.renderer.on("click", (t2, e2) => {
      this.options.interact && (this.seekTo(t2), this.emit("interaction", t2 * this.getDuration()), this.emit("click", t2, e2));
    }), this.renderer.on("dblclick", (t2, e2) => {
      this.emit("dblclick", t2, e2);
    }), this.renderer.on("scroll", (t2, e2) => {
      const i2 = this.getDuration();
      this.emit("scroll", t2 * i2, e2 * i2);
    }), this.renderer.on("render", () => {
      this.emit("redraw");
    }), this.renderer.on("rendered", () => {
      this.emit("redrawcomplete");
    }), this.renderer.on("dragstart", (t2) => {
      this.emit("dragstart", t2);
    }), this.renderer.on("dragend", (t2) => {
      this.emit("dragend", t2);
    }));
    {
      let t2;
      this.subscriptions.push(this.renderer.on("drag", (e2) => {
        if (!this.options.interact)
          return;
        let i2;
        this.renderer.renderProgress(e2), clearTimeout(t2), this.isPlaying() ? i2 = 0 : this.options.dragToSeek === true ? i2 = 200 : typeof this.options.dragToSeek == "object" && this.options.dragToSeek !== void 0 && (i2 = this.options.dragToSeek.debounceTime), t2 = setTimeout(() => {
          this.seekTo(e2);
        }, i2), this.emit("interaction", e2 * this.getDuration()), this.emit("drag", e2);
      }));
    }
  }
  initPlugins() {
    var t2;
    ((t2 = this.options.plugins) === null || t2 === void 0 ? void 0 : t2.length) && this.options.plugins.forEach((t3) => {
      this.registerPlugin(t3);
    });
  }
  unsubscribePlayerEvents() {
    this.mediaSubscriptions.forEach((t2) => t2()), this.mediaSubscriptions = [];
  }
  setOptions(t2) {
    this.options = Object.assign({}, this.options, t2), this.renderer.setOptions(this.options), t2.audioRate && this.setPlaybackRate(t2.audioRate), t2.mediaControls != null && (this.getMediaElement().controls = t2.mediaControls);
  }
  registerPlugin(t2) {
    return t2._init(this), this.plugins.push(t2), this.subscriptions.push(t2.once("destroy", () => {
      this.plugins = this.plugins.filter((e2) => e2 !== t2);
    })), t2;
  }
  getWrapper() {
    return this.renderer.getWrapper();
  }
  getScroll() {
    return this.renderer.getScroll();
  }
  setScroll(t2) {
    return this.renderer.setScroll(t2);
  }
  setScrollTime(t2) {
    const e2 = t2 / this.getDuration();
    this.renderer.setScrollPercentage(e2);
  }
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(e2, n2, s2, r2) {
    return t(this, void 0, void 0, function* () {
      var t2;
      if (this.emit("load", e2), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, !n2 && !s2) {
        const i2 = this.options.fetchParams || {};
        window.AbortController && !i2.signal && (this.abortController = new AbortController(), i2.signal = (t2 = this.abortController) === null || t2 === void 0 ? void 0 : t2.signal);
        const s3 = (t3) => this.emit("loading", t3);
        n2 = yield o.fetchBlob(e2, s3, i2);
      }
      this.setSrc(e2, n2);
      const a2 = r2 || this.getDuration() || (yield new Promise((t3) => {
        this.onMediaEvent("loadedmetadata", () => t3(this.getDuration()), { once: true });
      }));
      if (!e2 && !n2) {
        const t3 = this.getMediaElement();
        t3 instanceof d && (t3.duration = a2);
      }
      if (s2)
        this.decodedData = i.createBuffer(s2, a2 || 0);
      else if (n2) {
        const t3 = yield n2.arrayBuffer();
        this.decodedData = yield i.decode(t3, this.options.sampleRate);
      }
      this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData)), this.emit("ready", this.getDuration());
    });
  }
  load(e2, i2, n2) {
    return t(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio(e2, void 0, i2, n2);
      } catch (t2) {
        throw this.emit("error", t2), t2;
      }
    });
  }
  loadBlob(e2, i2, n2) {
    return t(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio("blob", e2, i2, n2);
      } catch (t2) {
        throw this.emit("error", t2), t2;
      }
    });
  }
  zoom(t2) {
    if (!this.decodedData)
      throw new Error("No audio loaded");
    this.renderer.zoom(t2), this.emit("zoom", t2);
  }
  getDecodedData() {
    return this.decodedData;
  }
  exportPeaks({ channels: t2 = 2, maxLength: e2 = 8e3, precision: i2 = 1e4 } = {}) {
    if (!this.decodedData)
      throw new Error("The audio has not been decoded yet");
    const n2 = Math.min(t2, this.decodedData.numberOfChannels), s2 = [];
    for (let t3 = 0; t3 < n2; t3++) {
      const n3 = this.decodedData.getChannelData(t3), r2 = [], o2 = n3.length / e2;
      for (let t4 = 0; t4 < e2; t4++) {
        const e3 = n3.slice(Math.floor(t4 * o2), Math.ceil((t4 + 1) * o2));
        let s3 = 0;
        for (let t5 = 0; t5 < e3.length; t5++) {
          const i3 = e3[t5];
          Math.abs(i3) > Math.abs(s3) && (s3 = i3);
        }
        r2.push(Math.round(s3 * i2) / i2);
      }
      s2.push(r2);
    }
    return s2;
  }
  getDuration() {
    let t2 = super.getDuration() || 0;
    return t2 !== 0 && t2 !== 1 / 0 || !this.decodedData || (t2 = this.decodedData.duration), t2;
  }
  toggleInteraction(t2) {
    this.options.interact = t2;
  }
  setTime(t2) {
    super.setTime(t2), this.updateProgress(t2), this.emit("timeupdate", t2);
  }
  seekTo(t2) {
    const e2 = this.getDuration() * t2;
    this.setTime(e2);
  }
  playPause() {
    return t(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  stop() {
    this.pause(), this.setTime(0);
  }
  skip(t2) {
    this.setTime(this.getCurrentTime() + t2);
  }
  empty() {
    this.load("", [[0]], 1e-3);
  }
  setMediaElement(t2) {
    this.unsubscribePlayerEvents(), super.setMediaElement(t2), this.initPlayerEvents();
  }
  exportImage() {
    return t(this, arguments, void 0, function* (t2 = "image/png", e2 = 1, i2 = "dataURL") {
      return this.renderer.exportImage(t2, e2, i2);
    });
  }
  destroy() {
    var t2;
    this.emit("destroy"), (t2 = this.abortController) === null || t2 === void 0 || t2.abort(), this.plugins.forEach((t3) => t3.destroy()), this.subscriptions.forEach((t3) => t3()), this.unsubscribePlayerEvents(), this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
};
u.BasePlugin = class extends e {
  constructor(t2) {
    super(), this.subscriptions = [], this.options = t2;
  }
  onInit() {
  }
  _init(t2) {
    this.wavesurfer = t2, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((t2) => t2());
  }
}, u.dom = r;

// dep:wavesurfer_js
var wavesurfer_js_default = u;
export {
  wavesurfer_js_default as default
};
//# sourceMappingURL=wavesurfer_js.js.map
